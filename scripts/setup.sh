#!/usr/bin/env bash
###############################################################################
# opendeclawed — Setup Script
#
# Interactive or non-interactive setup for the hardened OpenClaw stack.
# Credentials are persisted to .env and openclaw.json IMMEDIATELY as they
# are collected, so a crash never loses what you've already entered.
#
# Usage:
#   Interactive:     ./scripts/setup.sh
#   Non-interactive: ./scripts/setup.sh --non-interactive
#
# Non-interactive mode reads all values from environment variables or .env file.
# Interactive mode prompts for missing values using secure (silent) input for
# all secrets.
###############################################################################
set -euo pipefail

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
CYAN='\033[0;36m'; BOLD='\033[1m'; DIM='\033[2m'; NC='\033[0m'
info()  { echo -e "${GREEN}[+]${NC} $*"; }
warn()  { echo -e "${YELLOW}[!]${NC} $*"; }
error() { echo -e "${RED}[x]${NC} $*" >&2; exit 1; }
header(){ echo -e "\n${BOLD}${CYAN}── $* ──${NC}"; }
dim()   { echo -e "${DIM}    $*${NC}"; }

# ── Defaults ──────────────────────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_DIR="$(dirname "${SCRIPT_DIR}")"
CONFIG_DIR="${OPENCLAW_CONFIG_DIR:-${HOME}/.openclaw}"
WORKSPACE_DIR="${OPENCLAW_WORKSPACE_DIR:-${CONFIG_DIR}/workspace}"
COMPOSE_FILE="${REPO_DIR}/docker-compose.yml"
ENV_FILE="${REPO_DIR}/.env"
MODELS_DIR="${REPO_DIR}/models"
INTERACTIVE=true

EMBED_MODEL="${EMBED_MODEL_FILE:-nomic-embed-text-v1.5.Q5_K_M.gguf}"
EMBED_URL="https://huggingface.co/nomic-ai/nomic-embed-text-v1.5-GGUF/resolve/main/${EMBED_MODEL}"
CHAT_MODEL="${CHAT_MODEL_FILE:-Llama-3.2-3B-Instruct-Q5_K_M.gguf}"
CHAT_URL="https://huggingface.co/bartowski/Llama-3.2-3B-Instruct-GGUF/resolve/main/${CHAT_MODEL}"

# Credential vars — populated by prompts or environment
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
VIRUSTOTAL_API_KEY="${VIRUSTOTAL_API_KEY:-}"
CLOUDFLARE_TOKEN="${CLOUDFLARE_TOKEN:-}"
NORDVPN_TOKEN="${NORDVPN_TOKEN:-}"
TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN:-}"
DISCORD_BOT_TOKEN="${DISCORD_BOT_TOKEN:-}"
DISCORD_GUILD_ID="${DISCORD_GUILD_ID:-}"
INGRESS_MODE="${INGRESS_MODE:-local}"
EGRESS_SUBNET="${EGRESS_SUBNET:-172.28.0.0/24}"
GATEWAY_IP="${GATEWAY_IP:-172.17.0.1}"
TELEMETRY_ENABLED="${TELEMETRY_ENABLED:-false}"
TS_AUTHKEY="${TS_AUTHKEY:-}"
TS_HOSTNAME="${TS_HOSTNAME:-openclaw}"

# ── Parse arguments ───────────────────────────────────────────────────────
for arg in "$@"; do
    case "$arg" in
        --non-interactive) INTERACTIVE=false ;;
        --help|-h)
            echo "Usage: $0 [--non-interactive] [--help]"
            echo ""
            echo "  --non-interactive  Read all config from env vars / .env file"
            echo "  --help             Show this help"
            echo ""
            echo "Environment variables for non-interactive mode:"
            echo "  ANTHROPIC_API_KEY      Anthropic API key (required)"
            echo "  VIRUSTOTAL_API_KEY     VirusTotal API key (recommended)"
            echo "  INGRESS_MODE           local|tunnel|meshnet|tailscale (default: local)"
            echo "  CLOUDFLARE_TOKEN       Cloudflare tunnel token (if tunnel)"
            echo "  NORDVPN_TOKEN          NordVPN token (if meshnet)"
            echo "  TS_AUTHKEY             Tailscale auth key (if tailscale)"
            echo "  TS_HOSTNAME            Tailscale machine name (default: openclaw)"
            echo "  TELEMETRY_ENABLED      true|false (default: false)"
            echo "  TELEGRAM_BOT_TOKEN     Telegram bot token (optional)"
            echo "  DISCORD_BOT_TOKEN      Discord bot token (optional)"
            echo "  DISCORD_GUILD_ID       Discord server ID (if Discord)"
            exit 0
            ;;
    esac
done

###############################################################################
# ── Helpers ──────────────────────────────────────────────────────────────
###############################################################################

# Write or update a KEY=VALUE pair in .env. Creates .env if it doesn't exist.
# Usage: save_env KEY VALUE
save_env() {
    local key="$1" value="$2"

    # Create .env with header if it doesn't exist yet
    if [ ! -f "${ENV_FILE}" ]; then
        cat > "${ENV_FILE}" << HEADER
# Generated by setup.sh on $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# See .env.example for all available options.
# Permissions: 600 (owner read/write only)
HEADER
        chmod 600 "${ENV_FILE}"
    fi

    # Update existing key or append new one
    if grep -q "^${key}=" "${ENV_FILE}" 2>/dev/null; then
        # Use a temp file to avoid sed -i portability issues
        local tmpfile="${ENV_FILE}.tmp"
        grep -v "^${key}=" "${ENV_FILE}" > "${tmpfile}"
        echo "${key}=${value}" >> "${tmpfile}"
        mv "${tmpfile}" "${ENV_FILE}"
        chmod 600 "${ENV_FILE}"
    else
        echo "${key}=${value}" >> "${ENV_FILE}"
    fi
}

# Validate a credential matches its expected format.
# Returns 0 if valid or no pattern defined, 1 if invalid.
# Usage: validate_format VAR_NAME VALUE
validate_format() {
    local var_name="$1" value="$2"
    case "${var_name}" in
        ANTHROPIC_API_KEY)
            if [[ ! "${value}" =~ ^sk-ant- ]]; then
                warn "Doesn't look like an Anthropic API key (expected sk-ant-...)"
                warn "If using an OAuth token, this is fine — press Enter to re-enter or type 'accept' to keep it."
                read -rp "  > " override
                [[ "${override}" == "accept" ]] && return 0
                return 1
            fi
            ;;
        VIRUSTOTAL_API_KEY)
            if [[ ! "${value}" =~ ^[a-fA-F0-9]{64}$ ]]; then
                warn "Doesn't look like a VirusTotal key (expected 64-char hex string)"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
        CLOUDFLARE_TOKEN)
            if [[ ! "${value}" =~ ^eyJ ]]; then
                warn "Doesn't look like a Cloudflare tunnel token (expected eyJ... base64)"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
        TELEGRAM_BOT_TOKEN)
            if [[ ! "${value}" =~ ^[0-9]+:.+ ]]; then
                warn "Doesn't look like a Telegram bot token (expected 123456789:ABC...)"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
        DISCORD_BOT_TOKEN)
            # Discord tokens are base64-ish, typically 60-80 chars with dots
            if [[ ${#value} -lt 50 ]]; then
                warn "Discord bot token seems too short (typically 60+ chars)"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
        NORDVPN_TOKEN)
            if [[ ${#value} -lt 20 ]]; then
                warn "NordVPN token seems too short"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
        TS_AUTHKEY)
            if [[ ! "${value}" =~ ^tskey- ]]; then
                warn "Doesn't look like a Tailscale auth key (expected tskey-auth-... or tskey-client-...)"
                read -rp "  Accept anyway? [y/N]: " override
                [[ "${override}" =~ ^[Yy] ]] && return 0
                return 1
            fi
            ;;
    esac
    return 0
}

# Prompt for a secret value. Input is NOT echoed to the screen.
# Persists to .env immediately via save_env.
# Usage: ask_secret VAR_NAME "prompt text" [required|optional] [env_key]
# env_key defaults to VAR_NAME if not specified.
ask_secret() {
    local var_name="$1" prompt="$2" required="${3:-optional}" env_key="${4:-$1}"
    local current_val="${!var_name:-}"

    # If already set from env or previous run, keep it
    if [ -n "${current_val}" ]; then
        dim "  ${var_name}: already set (${#current_val} chars)"
        return 0
    fi

    # Non-interactive: skip optional, error on required
    if [ "${INTERACTIVE}" != true ]; then
        if [ "${required}" = "required" ]; then
            error "${var_name} is required but not set. Export it or use interactive mode."
        fi
        return 0
    fi

    echo ""
    if [ "${required}" = "required" ]; then
        echo -e "  ${BOLD}${prompt}${NC} ${RED}(required)${NC}"
    else
        echo -e "  ${prompt} ${DIM}(Enter to skip)${NC}"
    fi

    while true; do
        # -s = silent (no echo), -r = raw (no backslash escape)
        read -rsp "  > " current_val
        echo ""  # newline after silent input

        if [ -z "${current_val}" ]; then
            if [ "${required}" = "required" ]; then
                warn "This credential is required. Please enter a value."
                continue
            else
                dim "Skipped."
                return 0
            fi
        fi

        # Confirm by asking to type again
        read -rsp "  Confirm (paste again): " confirm_val
        echo ""

        if [ "${current_val}" = "${confirm_val}" ]; then
            # Validate format before accepting
            if ! validate_format "${var_name}" "${current_val}"; then
                warn "Re-enter the value."
                current_val=""
                continue
            fi
            # SECURITY: use printf -v instead of eval to prevent shell injection
            printf -v "$var_name" '%s' "$current_val"
            # Persist immediately so a crash doesn't lose it
            save_env "${env_key}" "${current_val}"
            info "Saved + persisted to .env (${#current_val} chars)"
            return 0
        else
            warn "Values don't match. Try again."
        fi
    done
}

# Prompt for a non-secret value (echoed normally).
ask_plain() {
    local var_name="$1" prompt="$2" default="${3:-}"
    local current_val="${!var_name:-${default}}"

    if [ "${INTERACTIVE}" = true ] && [ -z "${current_val}" ]; then
        read -rp "  ${prompt}: " current_val
    fi
    current_val="${current_val:-${default}}"
    printf -v "$var_name" '%s' "$current_val"
}

###############################################################################
header "Step 1/11 — Prerequisites"
###############################################################################

command -v docker >/dev/null 2>&1 || error "Docker not found. Install OrbStack (https://orbstack.dev) or Docker Desktop."
docker compose version >/dev/null 2>&1 || error "Docker Compose V2 not found."

DOCKER_VERSION=$(docker version --format '{{.Server.Version}}' 2>/dev/null || echo "unknown")
info "Docker Engine: ${DOCKER_VERSION}"

if pgrep -q OrbStack 2>/dev/null; then
    info "Runtime: OrbStack"
elif pgrep -q Docker 2>/dev/null || pgrep -q com.docker 2>/dev/null; then
    info "Runtime: Docker Desktop"
else
    info "Runtime: native Docker (or undetected)"
fi

###############################################################################
header "Step 2/11 — Secrets detection (TruffleHog)"
###############################################################################

# Install trufflehog if missing
if command -v trufflehog >/dev/null 2>&1; then
    info "TruffleHog: $(trufflehog --version 2>&1 | head -1)"
else
    info "Installing TruffleHog (secrets scanner)..."
    if command -v brew >/dev/null 2>&1; then
        brew install trufflehog 2>/dev/null || warn "brew install trufflehog failed — install manually"
    else
        curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh \
            | sh -s -- -b /usr/local/bin 2>/dev/null \
            || warn "TruffleHog auto-install failed. Install manually: https://github.com/trufflesecurity/trufflehog#installation"
    fi
    if command -v trufflehog >/dev/null 2>&1; then
        info "TruffleHog installed."
    else
        warn "TruffleHog not available — secrets scanning will be skipped."
        warn "Install later: brew install trufflehog"
    fi
fi

# Install pre-commit if missing
if command -v pre-commit >/dev/null 2>&1; then
    info "pre-commit: $(pre-commit --version 2>&1)"
else
    info "Installing pre-commit (git hook framework)..."
    if command -v brew >/dev/null 2>&1; then
        brew install pre-commit 2>/dev/null || true
    elif command -v pip3 >/dev/null 2>&1; then
        pip3 install --user pre-commit 2>/dev/null \
            || pip3 install --break-system-packages pre-commit 2>/dev/null \
            || true
    fi
    if command -v pre-commit >/dev/null 2>&1; then
        info "pre-commit installed."
    else
        warn "pre-commit not available — install later: brew install pre-commit"
    fi
fi

# Install git hooks if this is a git repo
if [ -d "${REPO_DIR}/.git" ]; then
    if command -v pre-commit >/dev/null 2>&1; then
        (cd "${REPO_DIR}" && pre-commit install 2>/dev/null) && info "Pre-commit hooks installed." || true
    else
        dim "pre-commit not found — run 'brew install pre-commit && pre-commit install' to enable git hooks."
    fi
else
    dim "Not a git repo — run 'pre-commit install' after git init."
fi

###############################################################################
header "Step 3/11 — Config directories + .env"
###############################################################################

mkdir -p "${CONFIG_DIR}" "${WORKSPACE_DIR}"
chmod 700 "${CONFIG_DIR}"
chmod 700 "${WORKSPACE_DIR}"
info "Config: ${CONFIG_DIR} (mode 700)"

# Load existing .env if present (re-run scenario)
if [ -f "${ENV_FILE}" ]; then
    # shellcheck source=/dev/null
    set +u  # .env may reference unset vars
    source "${ENV_FILE}" 2>/dev/null || true
    set -u
    info "Loaded existing .env (re-run detected)"
fi

# Load existing credentials from openclaw.json (re-run scenario)
OPENCLAW_JSON="${CONFIG_DIR}/openclaw.json"
if [ -f "${OPENCLAW_JSON}" ]; then
    if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
        ANTHROPIC_API_KEY=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    # 2026.x schema: env.ANTHROPIC_API_KEY
    key = cfg.get('env',{}).get('ANTHROPIC_API_KEY','')
    # Legacy fallback: providers.anthropic.apiKey
    if not key:
        key = cfg.get('providers',{}).get('anthropic',{}).get('apiKey','')
    print(key)
except: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
        [ -n "${ANTHROPIC_API_KEY}" ] && info "Loaded Anthropic API key from openclaw.json"
    fi
    if [ -z "${TELEGRAM_BOT_TOKEN:-}" ]; then
        TELEGRAM_BOT_TOKEN=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    # 2026.x: "token"; legacy: "botToken"
    t = cfg.get('channels',{}).get('telegram',{})
    print(t.get('token','') or t.get('botToken',''))
except: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
        [ -n "${TELEGRAM_BOT_TOKEN}" ] && info "Loaded Telegram bot token from openclaw.json"
    fi
    if [ -z "${DISCORD_BOT_TOKEN:-}" ]; then
        DISCORD_BOT_TOKEN=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    d = cfg.get('channels',{}).get('discord',{})
    print(d.get('token','') or d.get('botToken',''))
except: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
        [ -n "${DISCORD_BOT_TOKEN}" ] && info "Loaded Discord bot token from openclaw.json"
    fi
    if [ -z "${DISCORD_GUILD_ID:-}" ]; then
        DISCORD_GUILD_ID=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    d = cfg.get('channels',{}).get('discord',{})
    # 2026.x: guilds dict; legacy: guildId string
    guilds = d.get('guilds',{})
    if guilds:
        print(list(guilds.keys())[0])
    else:
        print(d.get('guildId',''))
except: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
    fi
fi

###############################################################################
header "Step 4/11 — Credentials"
###############################################################################

echo ""
echo -e "${BOLD}  All secrets use secure input — nothing is echoed to screen.${NC}"
echo -e "${DIM}  Credentials are saved to .env IMMEDIATELY — a crash won't lose them.${NC}"
echo -e "${DIM}  See docs/prerequisites.md for how to obtain each key.${NC}"

# ── Required ──
echo ""
echo -e "  ${BOLD}── Required ──${NC}"
dim "Anthropic API key powers all Claude model calls."
dim "Get one at: https://console.anthropic.com → Settings → API Keys"
dim "Or use a Claude Pro/Max OAuth token from the onboarding wizard."
ask_secret ANTHROPIC_API_KEY "Anthropic API key (sk-ant-...)" required ANTHROPIC_API_KEY

# ── Recommended ──
echo ""
echo -e "  ${BOLD}── Recommended ──${NC}"
dim "VirusTotal API key enables skill scanning before install."
dim "Free: https://www.virustotal.com → avatar → API key"
ask_secret VIRUSTOTAL_API_KEY "VirusTotal API key" optional VIRUSTOTAL_API_KEY

# ── Ingress ──
echo ""
echo -e "  ${BOLD}── Ingress mode ──${NC}"
if [ "${INTERACTIVE}" = true ] && [ -z "${CLOUDFLARE_TOKEN}" ] && [ -z "${NORDVPN_TOKEN}" ]; then
    echo ""
    echo "  How will you access OpenClaw?"
    echo "    1) local     — 127.0.0.1 only (default, most secure)"
    echo "    2) tunnel    — Cloudflare Tunnel (zero exposed ports, internet-accessible)"
    echo "    3) meshnet   — NordVPN Meshnet (P2P, no public DNS)"
    echo "    4) tailscale — Tailscale mesh VPN (WireGuard, ACL-controlled)"
    echo ""
    read -rp "  Choose [1]: " ingress_choice
    case "${ingress_choice}" in
        2|tunnel)
            INGRESS_MODE="tunnel"
            dim "Create a tunnel at: https://one.dash.cloudflare.com → Tunnels"
            dim "See docs/setup-guide.md for Cloudflare Access + GitHub OAuth setup."
            ask_secret CLOUDFLARE_TOKEN "Cloudflare Tunnel token (eyJ...)" required CLOUDFLARE_TOKEN
            ;;
        3|meshnet)
            INGRESS_MODE="meshnet"
            dim "Get token at: https://my.nordaccount.com → Services → NordVPN → Access Token"
            ask_secret NORDVPN_TOKEN "NordVPN service token" required NORDVPN_TOKEN
            ;;
        4|tailscale)
            INGRESS_MODE="tailscale"
            dim "Generate an auth key at: https://login.tailscale.com/admin/settings/keys"
            dim "Use a reusable key for unattended restarts. See docs/setup-guide.md."
            ask_secret TS_AUTHKEY "Tailscale auth key (tskey-auth-...)" required TS_AUTHKEY
            echo ""
            read -rp "  Tailscale hostname [openclaw]: " ts_host
            TS_HOSTNAME="${ts_host:-openclaw}"
            save_env TS_HOSTNAME "${TS_HOSTNAME}"
            info "Tailscale hostname: ${TS_HOSTNAME}"
            ;;
        *)
            INGRESS_MODE="local"
            info "Ingress: local-only (127.0.0.1:18789)"
            ;;
    esac
else
    if [ -n "${CLOUDFLARE_TOKEN}" ]; then INGRESS_MODE="tunnel"; fi
    if [ -n "${NORDVPN_TOKEN}" ]; then INGRESS_MODE="meshnet"; fi
    if [ -n "${TS_AUTHKEY}" ]; then INGRESS_MODE="tailscale"; fi
    info "Ingress: ${INGRESS_MODE} (from environment)"
fi

# ── Messaging (optional) ──
echo ""
echo -e "  ${BOLD}── Messaging channels (optional) ──${NC}"
dim "Configure at least one to interact with OpenClaw remotely."

# Telegram
if [ "${INTERACTIVE}" = true ] && [ -z "${TELEGRAM_BOT_TOKEN}" ]; then
    echo ""
    read -rp "  Set up Telegram bot? [y/N]: " setup_telegram
    if [[ "${setup_telegram}" =~ ^[Yy] ]]; then
        dim "Create a bot: message @BotFather on Telegram → /newbot"
        dim "Then /setjoingroups → Disable, /setprivacy → Enable"
        ask_secret TELEGRAM_BOT_TOKEN "Telegram bot token (123456789:ABC...)" optional TELEGRAM_BOT_TOKEN
    fi
fi

# Discord
if [ "${INTERACTIVE}" = true ] && [ -z "${DISCORD_BOT_TOKEN}" ]; then
    echo ""
    read -rp "  Set up Discord bot? [y/N]: " setup_discord
    if [[ "${setup_discord}" =~ ^[Yy] ]]; then
        dim "Create at: https://discord.com/developers/applications → New App → Bot"
        dim "Enable Message Content Intent under Privileged Gateway Intents."
        ask_secret DISCORD_BOT_TOKEN "Discord bot token" optional DISCORD_BOT_TOKEN
        ask_plain  DISCORD_GUILD_ID   "Discord server (guild) ID"
        [ -n "${DISCORD_GUILD_ID}" ] && save_env DISCORD_GUILD_ID "${DISCORD_GUILD_ID}"
    fi
fi

# ── Telemetry (opt-in) ──
if [ "${INTERACTIVE}" = true ] && [ "${TELEMETRY_ENABLED}" != "true" ]; then
    echo ""
    echo -e "  ${BOLD}── Telemetry (opt-in) ──${NC}"
    dim "OpenClaw can send anonymous usage telemetry to help the project."
    dim "No credentials, prompts, or PII are ever transmitted."
    read -rp "  Enable native telemetry? [y/N]: " enable_telem
    if [[ "${enable_telem}" =~ ^[Yy] ]]; then
        TELEMETRY_ENABLED="true"
    else
        TELEMETRY_ENABLED="false"
    fi
    save_env TELEMETRY_ENABLED "${TELEMETRY_ENABLED}"
fi

info "All credentials collected + persisted."

###############################################################################
header "Step 5/11 — Gateway token"
###############################################################################

if [ -f "${CONFIG_DIR}/.gateway-token" ]; then
    OPENCLAW_GATEWAY_TOKEN="$(cat "${CONFIG_DIR}/.gateway-token")"
    info "Using existing gateway token."
elif [ -n "${OPENCLAW_GATEWAY_TOKEN:-}" ]; then
    echo -n "${OPENCLAW_GATEWAY_TOKEN}" > "${CONFIG_DIR}/.gateway-token"
    chmod 600 "${CONFIG_DIR}/.gateway-token"
    info "Saved gateway token from environment."
else
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
    echo -n "${OPENCLAW_GATEWAY_TOKEN}" > "${CONFIG_DIR}/.gateway-token"
    chmod 600 "${CONFIG_DIR}/.gateway-token"
    info "Generated new gateway token (64 hex chars)."
fi
save_env OPENCLAW_GATEWAY_TOKEN "${OPENCLAW_GATEWAY_TOKEN}"

# Also persist non-secret config to .env
save_env OPENCLAW_CONFIG_DIR "${CONFIG_DIR}"
save_env OPENCLAW_WORKSPACE_DIR "${WORKSPACE_DIR}"
save_env EMBED_MODEL_FILE "${EMBED_MODEL}"
save_env CHAT_MODEL_FILE "${CHAT_MODEL}"
save_env EGRESS_SUBNET "${EGRESS_SUBNET:-172.28.0.0/24}"
save_env GATEWAY_IP "${GATEWAY_IP:-172.17.0.1}"
save_env INGRESS_MODE "${INGRESS_MODE}"
save_env LLAMA_IMAGE "${LLAMA_IMAGE:-ghcr.io/ggml-org/llama.cpp:server}"

# Write empty defaults for optional profile vars so Docker Compose
# doesn't emit "variable is not set" warnings for unused profiles.
[ -z "${CLOUDFLARE_TOKEN}" ]    && save_env CLOUDFLARE_TOKEN ""
[ -z "${TS_AUTHKEY}" ]          && save_env TS_AUTHKEY ""
[ -z "${TS_HOSTNAME}" ]         && save_env TS_HOSTNAME "openclaw"

###############################################################################
header "Step 6/11 — Download local models"
###############################################################################

mkdir -p "${MODELS_DIR}"

# Known-good SHA256 checksums for default models.
# Update these when changing default models in the vars above.
# Uses a function instead of associative arrays for bash 3.2 (macOS) compatibility.
get_model_checksum() {
    case "$1" in
        nomic-embed-text-v1.5.Q5_K_M.gguf)  echo "0c7930f6c4f6f29b7da5046e3a2c0832aa3f602db3de5760a95f0582dbd3d6e6" ;;
        Llama-3.2-3B-Instruct-Q5_K_M.gguf)  echo "0b94ccd04d908304cec5246a3d942b64417a423bc5c6d47c73bc557e590b5194" ;;
        *)                                    echo "" ;;
    esac
}

# Cross-platform SHA256 (macOS has shasum, Linux has sha256sum)
compute_sha256() {
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "$1" | cut -d' ' -f1
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "$1" | cut -d' ' -f1
    else
        warn "No sha256sum or shasum found — skipping checksum"
        echo ""
    fi
}

download_model() {
    local name="$1" url="$2" dest="${MODELS_DIR}/$1"
    if [ -f "${dest}" ]; then
        info "Cached: ${name}"
    else
        info "Downloading ${name}..."
        curl -L --progress-bar -o "${dest}" "${url}" || error "Failed to download ${name}"
        info "Downloaded: ${name}"
    fi
}

verify_model() {
    local name="$1" dest="${MODELS_DIR}/$1"
    local expected
    expected="$(get_model_checksum "${name}")"

    if [ -z "${expected}" ] || [ "${expected}" = "PLACEHOLDER_UPDATE_AFTER_FIRST_DOWNLOAD" ]; then
        local actual
        actual="$(compute_sha256 "${dest}")"
        if [ -n "${actual}" ]; then
            warn "No checksum on record for ${name}"
            warn "  Computed: ${actual}"
            warn "  Update get_model_checksum() in setup.sh with this value after verifying the file."
        fi
        return 0
    fi

    info "Verifying integrity: ${name}..."
    local actual
    actual="$(compute_sha256 "${dest}")"
    if [ -z "${actual}" ]; then
        warn "Cannot verify ${name} — no checksum tool available"
        return 0
    fi
    if [ "${actual}" = "${expected}" ]; then
        info "Checksum OK: ${name}"
    else
        error "CHECKSUM MISMATCH for ${name}!\n  Expected: ${expected}\n  Got:      ${actual}\n  The model file may be corrupted or tampered with. Delete it and re-run."
    fi
}

download_model "${EMBED_MODEL}" "${EMBED_URL}"
download_model "${CHAT_MODEL}" "${CHAT_URL}"
verify_model "${EMBED_MODEL}"
verify_model "${CHAT_MODEL}"

###############################################################################
header "Step 7/11 — Write openclaw.json"
###############################################################################

OPENCLAW_JSON="${CONFIG_DIR}/openclaw.json"

if [ -f "${OPENCLAW_JSON}" ]; then
    info "Config exists, not overwriting: ${OPENCLAW_JSON}"
    info "Delete it and re-run to regenerate."
else
    # SECURITY: Pass all secrets via environment variables to Python, NOT via
    # shell interpolation into code. Shell interpolation breaks on quotes,
    # backslashes, and $ chars in API keys, and is an injection vector.
    ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY}" \
    TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN}" \
    DISCORD_BOT_TOKEN="${DISCORD_BOT_TOKEN}" \
    DISCORD_GUILD_ID="${DISCORD_GUILD_ID}" \
    INGRESS_MODE="${INGRESS_MODE}" \
    LITELLM_PORT="${LITELLM_PORT:-4000}" \
    LITELLM_MASTER_KEY="${LITELLM_MASTER_KEY:-sk-opendeclawed-internal}" \
    OPENCLAW_JSON_PATH="${OPENCLAW_JSON}" \
    OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN}" \
    TS_HOSTNAME="${TS_HOSTNAME:-openclaw}" \
    python3 << 'PYEOF'
import json, os, secrets
from datetime import datetime, timezone

litellm_port = os.environ.get("LITELLM_PORT", "4000")
litellm_key  = os.environ.get("LITELLM_MASTER_KEY", "sk-opendeclawed-internal")
ingress_mode = os.environ.get("INGRESS_MODE", "local")
gateway_token = os.environ.get("OPENCLAW_GATEWAY_TOKEN", secrets.token_hex(24))
ts_hostname  = os.environ.get("TS_HOSTNAME", "openclaw")

now = datetime.now(timezone.utc).isoformat()

config = {
    "meta": {
        "lastTouchedVersion": "2026.2.14",
        "lastTouchedAt": now
    },
    "wizard": {
        "lastRunAt": now,
        "lastRunVersion": "2026.2.14",
        "lastRunCommand": "onboard",
        "lastRunMode": "local"
    },
    "env": {},
    "models": {
        "providers": {
            "litellm": {
                "baseUrl": f"http://litellm:{litellm_port}/v1",
                "apiKey": litellm_key,
                "api": "openai-completions",
                "models": [
                    {
                        "id": "local/local-chat",
                        "name": "Local Chat (via LiteLLM)",
                        "contextWindow": 4096,
                        "maxTokens": 2048
                    },
                    {
                        "id": "local/local-embed",
                        "name": "Local Embed (via LiteLLM)",
                        "contextWindow": 8192,
                        "maxTokens": 512
                    }
                ]
            }
        }
    },
    "agents": {
        "defaults": {
            "model": {
                "primary": "anthropic/claude-sonnet-4-5-20250929",
                "fallbacks": [
                    "anthropic/claude-haiku-4-5-20251001"
                ]
            },
            "models": {
                "anthropic/claude-sonnet-4-5-20250929": {"alias": "Sonnet"},
                "anthropic/claude-haiku-4-5-20251001":  {"alias": "Haiku"},
                "anthropic/claude-opus-4-6":            {"alias": "Opus"}
            },
            "workspace": "/home/node/.openclaw/workspace",
            "heartbeat": {
                "every": "60m",
                "target": "last"
            },
            "sandbox": {
                "mode": "non-main",
                "scope": "agent"
            }
        }
    },
    "commands": {
        "native": "auto",
        "nativeSkills": "auto"
    },
    "gateway": {
        "port": 18789,
        "mode": "local",
        "bind": "loopback" if ingress_mode == "local" else "lan",
        "auth": {
            "mode": "token",
            "token": gateway_token
        },
        "tailscale": {
            "mode": "serve" if ingress_mode == "tailscale" else "off",
            "resetOnExit": False
        }
    }
}

# Inject Anthropic API key
api_key = os.environ.get("ANTHROPIC_API_KEY", "")
if api_key:
    config["env"]["ANTHROPIC_API_KEY"] = api_key

# Inject channel configs with secure defaults
telegram_token = os.environ.get("TELEGRAM_BOT_TOKEN", "")
discord_token  = os.environ.get("DISCORD_BOT_TOKEN", "")
discord_guild  = os.environ.get("DISCORD_GUILD_ID", "")

if telegram_token or discord_token:
    config["channels"] = {}
    config["plugins"] = {"entries": {}}

    if telegram_token:
        config["channels"]["telegram"] = {
            "enabled": True,
            "dmPolicy": "pairing",
            "botToken": telegram_token,
            "groupPolicy": "allowlist",
            "streamMode": "partial"
        }
        config["plugins"]["entries"]["telegram"] = {"enabled": True}

    if discord_token:
        discord_cfg = {
            "enabled": True,
            "token": discord_token,
            "groupPolicy": "allowlist"
        }
        if discord_guild:
            discord_cfg["guilds"] = {
                discord_guild: {"requireMention": True}
            }
        config["channels"]["discord"] = discord_cfg
        config["plugins"]["entries"]["discord"] = {"enabled": True}

# Remove empty env/plugins if nothing was set
if not config["env"]:
    del config["env"]
if "plugins" in config and not config["plugins"]["entries"]:
    del config["plugins"]

out_path = os.environ.get("OPENCLAW_JSON_PATH",
                          os.path.expanduser("~/.openclaw/openclaw.json"))
with open(out_path, "w") as f:
    json.dump(config, f, indent=2)
PYEOF

    chmod 600 "${OPENCLAW_JSON}"
    info "Written: ${OPENCLAW_JSON} (mode 600)"
fi

###############################################################################
header "Step 8/11 — Verify .env"
###############################################################################

# .env has been built incrementally by save_env calls above.
# Just verify it exists and has correct permissions.
if [ -f "${ENV_FILE}" ]; then
    chmod 600 "${ENV_FILE}"
    local_keys=$(grep -c '=' "${ENV_FILE}" 2>/dev/null || echo 0)
    info ".env: ${local_keys} keys, mode 600"
else
    warn ".env missing — this shouldn't happen. Re-run setup."
fi

###############################################################################
header "Step 9/11 — Load models into Docker volume"
###############################################################################

info "Loading models into Docker volume..."
docker volume create llama-models 2>/dev/null || true
docker run --rm \
    -v "${MODELS_DIR}:/src:ro" \
    -v llama-models:/dst \
    alpine sh -c "cp /src/*.gguf /dst/ 2>/dev/null || true"
info "Models loaded."

# ── Check for OpenClaw image ──
OPENCLAW_IMAGE="${OPENCLAW_IMAGE:-openclaw:local}"
if ! docker image inspect "${OPENCLAW_IMAGE}" >/dev/null 2>&1; then
    warn "OpenClaw image '${OPENCLAW_IMAGE}' not found locally."
    echo ""
    echo "  You need to build or pull the OpenClaw image before starting."
    echo ""
    echo "  Option A — Build from source (recommended, most secure):"
    echo "    git clone https://github.com/openclaw/openclaw /tmp/openclaw-src"
    echo "    docker build -t openclaw:local -f /tmp/openclaw-src/Dockerfile /tmp/openclaw-src"
    echo ""
    echo "  Option B — Pull pre-built from Docker Hub:"
    echo "    docker pull alpine/openclaw"
    echo "    # Then set OPENCLAW_IMAGE=alpine/openclaw in .env"
    echo ""
    if [ "${INTERACTIVE}" = true ]; then
        read -rp "  Try pulling alpine/openclaw now? [y/N]: " pull_choice
        if [[ "${pull_choice}" =~ ^[Yy] ]]; then
            info "Pulling alpine/openclaw..."
            docker pull alpine/openclaw || error "Pull failed. Build from source instead."
            OPENCLAW_IMAGE="alpine/openclaw"
            save_env OPENCLAW_IMAGE "${OPENCLAW_IMAGE}"
            info "Using image: ${OPENCLAW_IMAGE}"
        else
            warn "Skipping — set OPENCLAW_IMAGE in .env and re-run, or build locally first."
        fi
    fi
fi

###############################################################################
header "Step 10/11 — Start stack"
###############################################################################

# Onboarding — config is pre-populated, wizard should not be needed.
# Offer to run it anyway in interactive mode (default: skip).
if [ "${INTERACTIVE}" = true ]; then
    echo ""
    dim "Config is fully pre-populated. The onboarding wizard is not required."
    read -rp "  Run OpenClaw onboarding wizard anyway? [y/N]: " run_onboard
    if [[ "${run_onboard}" =~ ^[Yy] ]]; then
        info "Starting onboarding wizard..."
        # CLI entrypoint is "node dist/index.js", so just pass the subcommand.
        docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" --profile cli \
            run --rm openclaw-cli onboard --no-install-daemon \
            || warn "Onboarding exited. Re-run: docker compose --profile cli run --rm openclaw-cli onboard"
        # Clean up containers from onboarding attempt before starting the full stack.
        # Without this, stale port/network allocations cause "Address already in use".
        docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" down --remove-orphans 2>/dev/null || true
    fi
fi

# Build profile flags
PROFILES=""

# LLM backend: containerized llama.cpp via LiteLLM proxy
# To use an external backend (MLX, Ollama, vLLM), edit litellm_config.yaml
# after setup to point at your host server (e.g. host.docker.internal:8091).
PROFILES="--profile llama"

# ── Generate litellm_config.yaml (LLM router config) ──────────────────
# LiteLLM sits between OpenClaw and the actual LLM backends. All local
# model traffic goes through litellm:4000. To swap backends later, just
# edit this YAML — no openclaw.json changes needed.
LITELLM_CONFIG="${REPO_DIR}/litellm_config.yaml"
LITELLM_PORT="${LITELLM_PORT:-4000}"

cat > "${LITELLM_CONFIG}" << LITELLMEOF
# LiteLLM Proxy configuration — generated by setup.sh
# Edit this file to add/change LLM backends without modifying openclaw.json.
#
# To use MLX (Apple Silicon), Ollama, or another backend instead of llama.cpp:
#   1. Change the api_base URLs below to point at your server
#      e.g. http://host.docker.internal:8091/v1 for a host-native server
#   2. Restart: docker compose restart litellm
#
# To add a second backend for failover, duplicate the model entry with a
# different api_base. LiteLLM will load-balance automatically.
#
# Docs: https://docs.litellm.ai/docs/proxy/configs

model_list:
  # ── Chat / completion model (llama.cpp container) ──
  - model_name: local-chat
    litellm_params:
      model: openai/local-chat
      api_base: "http://llama-chat:${CHAT_PORT:-8091}/v1"
      api_key: "not-needed"

  # ── Embedding model (llama.cpp container) ──
  - model_name: local-embed
    litellm_params:
      model: openai/local-embed
      api_base: "http://llama-embed:${EMBED_PORT:-8090}/v1"
      api_key: "not-needed"

general_settings:
  master_key: "\${LITELLM_MASTER_KEY}"
LITELLMEOF

info "Written: ${LITELLM_CONFIG}"
save_env LITELLM_PORT "${LITELLM_PORT}"

case "${INGRESS_MODE}" in
    tunnel)    PROFILES="${PROFILES} --profile tunnel" ;;
    meshnet)   PROFILES="${PROFILES} --profile meshnet" ;;
    tailscale) PROFILES="${PROFILES} --profile tailscale" ;;
esac

# Ask about monitoring
ENABLE_MONITOR="${ENABLE_MONITOR:-}"
if [ "${INTERACTIVE}" = true ] && [ -z "${ENABLE_MONITOR}" ]; then
    echo ""
    read -rp "  Enable monitoring (Uptime Kuma + Watchtower + Dozzle logs)? [Y/n]: " enable_mon
    if [[ ! "${enable_mon}" =~ ^[Nn] ]]; then
        PROFILES="${PROFILES} --profile monitor"
    fi
elif [ "${ENABLE_MONITOR}" = "true" ]; then
    PROFILES="${PROFILES} --profile monitor"
fi

info "Starting stack..."
docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" ${PROFILES} up -d

###############################################################################
header "Step 11/11 — Validate"
###############################################################################

sleep 3

docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" ps --format '{{.Name}}\t{{.Status}}' 2>/dev/null \
    | while IFS=$'\t' read -r name status; do
        info "  ${name}: ${status}"
    done

# Firewall check
GATEWAY_ID=$(docker ps -q -f name=opendeclawed-gateway 2>/dev/null || true)
if [ -n "${GATEWAY_ID}" ]; then
    if docker exec "${GATEWAY_ID}" curl -sf --connect-timeout 3 http://192.168.1.1/ 2>/dev/null; then
        warn "FIREWALL CHECK FAILED — containers can reach LAN!"
    else
        info "FIREWALL CHECK PASSED — LAN unreachable from containers"
    fi
fi

# Secrets scan — verify nothing leaked into tracked files
if command -v trufflehog >/dev/null 2>&1; then
    info "Running TruffleHog secrets scan on working tree..."
    if trufflehog filesystem "${REPO_DIR}" \
        --exclude-paths="${REPO_DIR}/.trufflehog-config.yaml" \
        --no-update --fail 2>/dev/null; then
        info "SECRETS SCAN PASSED — no credentials detected in repo files"
    else
        warn "SECRETS SCAN FLAGGED ISSUES — review: ./scripts/scan-secrets.sh"
    fi
else
    dim "TruffleHog not installed — skipping secrets scan."
fi

# ── Detect ingress IPs ───────────────────────────────────────────────
# Wait for mesh/tunnel containers to establish connections, then
# extract assigned IPs for the access URL summary.

detect_ingress_ip() {
    local mode="${1}"
    local max_wait=30
    local elapsed=0

    case "${mode}" in
        tailscale)
            printf "  Waiting for Tailscale to connect"
            while [ "${elapsed}" -lt "${max_wait}" ]; do
                TS_IP=$(docker exec opendeclawed-tailscale tailscale ip -4 2>/dev/null) && break
                printf "."
                sleep 2
                elapsed=$((elapsed + 2))
            done
            echo ""
            if [ -n "${TS_IP:-}" ]; then
                TS_FQDN=$(docker exec opendeclawed-tailscale tailscale status --json 2>/dev/null \
                    | python3 -c "import sys,json; print(json.load(sys.stdin)['Self']['DNSName'].rstrip('.'))" 2>/dev/null) || true
                info "Tailscale IP: ${TS_IP}"
                [ -n "${TS_FQDN:-}" ] && info "Tailscale FQDN: ${TS_FQDN}"
            else
                warn "Tailscale not connected yet. Check: docker logs opendeclawed-tailscale"
            fi
            ;;
        meshnet)
            printf "  Waiting for NordVPN meshnet"
            while [ "${elapsed}" -lt "${max_wait}" ]; do
                MESH_IP=$(docker exec opendeclawed-nordvpn nordvpn meshnet peer list 2>/dev/null \
                    | grep -oE 'Address: [0-9.]+' | head -1 | awk '{print $2}') && [ -n "${MESH_IP}" ] && break
                printf "."
                sleep 2
                elapsed=$((elapsed + 2))
            done
            echo ""
            if [ -n "${MESH_IP:-}" ]; then
                info "Meshnet IP: ${MESH_IP}"
            else
                warn "Meshnet not ready yet. Check: docker logs opendeclawed-nordvpn"
            fi
            ;;
    esac
}

# Run detection for active ingress mode
case "${INGRESS_MODE}" in
    tailscale|meshnet) detect_ingress_ip "${INGRESS_MODE}" ;;
esac

###############################################################################
# ── Summary ──
###############################################################################

echo ""
echo "======================================================================"
echo -e "  ${BOLD}${GREEN}Setup complete.${NC}"
echo "======================================================================"
echo ""
echo "  Credentials stored:"
echo "    Anthropic API key:  ~/.openclaw/openclaw.json + .env"
[ -n "${VIRUSTOTAL_API_KEY}" ] && \
echo "    VirusTotal API key: .env"
[ -n "${CLOUDFLARE_TOKEN}" ] && \
echo "    Cloudflare token:   .env"
[ -n "${NORDVPN_TOKEN}" ] && \
echo "    NordVPN token:      .env"
[ -n "${TS_AUTHKEY}" ] && \
echo "    Tailscale auth key: .env"
[ -n "${TELEGRAM_BOT_TOKEN}" ] && \
echo "    Telegram bot token: ~/.openclaw/openclaw.json + .env"
[ -n "${DISCORD_BOT_TOKEN}" ] && \
echo "    Discord bot token:  ~/.openclaw/openclaw.json + .env"
echo "    Gateway token:      ~/.openclaw/.gateway-token + .env"
echo ""
echo "  File permissions:"
echo "    ~/.openclaw/            → 700 (owner only)"
echo "    ~/.openclaw/openclaw.json → 600"
echo "    .env                    → 600"
echo "    ~/.openclaw/.gateway-token → 600"
echo ""
echo "  Ingress: ${INGRESS_MODE}"
echo ""
case "${INGRESS_MODE}" in
    local)
        echo "  Access URLs:"
        echo "    Gateway:      http://127.0.0.1:${GATEWAY_PORT:-18789}/"
        echo "    Uptime Kuma:  http://127.0.0.1:${KUMA_PORT:-3001}/"
        echo "    Dozzle Logs:  http://127.0.0.1:${DOZZLE_PORT:-5005}/"
        ;;
    tunnel)
        TUNNEL_HOST="${CLOUDFLARE_TUNNEL_ROUTE:-openclaw.example.com}"
        echo "  Access URLs:"
        echo "    Gateway:      https://${TUNNEL_HOST}/"
        echo "    Uptime Kuma:  https://${TUNNEL_HOST}/kuma/"
        echo "    Dozzle Logs:  https://${TUNNEL_HOST}/logs/"
        ;;
    tailscale)
        BASE="${TS_FQDN:-${TS_HOSTNAME:-openclaw}.<your-tailnet>.ts.net}"
        echo "  Access URLs:"
        echo "    Gateway:      https://${BASE}/"
        echo "    Uptime Kuma:  https://${BASE}/kuma/"
        echo "    Dozzle Logs:  https://${BASE}/logs/"
        [ -n "${TS_IP:-}" ] && echo "    Tailscale IP: ${TS_IP}"
        ;;
    meshnet)
        echo "  Access URLs:"
        if [ -n "${MESH_IP:-}" ]; then
            echo "    Gateway:      https://${MESH_IP}/"
            echo "    Uptime Kuma:  https://${MESH_IP}/kuma/"
            echo "    Dozzle Logs:  https://${MESH_IP}/logs/"
            echo "    Meshnet IP:   ${MESH_IP}"
        else
            echo "    (Meshnet IP not yet available — check docker logs opendeclawed-nordvpn)"
        fi
        ;;
esac
echo "  Telemetry: ${TELEMETRY_ENABLED}"
echo ""
echo "  Commands:"
echo "    Logs:    docker compose logs -f"
echo "    Stop:    docker compose down"
echo "    Doctor:  docker compose run --rm --profile cli openclaw-cli doctor"
echo "    Health:  curl http://127.0.0.1:${GATEWAY_PORT:-18789}/health"
echo "    Secrets: ./scripts/scan-secrets.sh        (scan working tree)"
echo "             ./scripts/scan-secrets.sh --full  (scan git history)"
[ -n "${VIRUSTOTAL_API_KEY}" ] && \
echo "    Install: \"install skill <name>\" via Telegram (safe-install skill)"
if [[ "${PROFILES}" == *"monitor"* ]]; then
echo ""
echo "  Monitoring:"
echo "    Uptime Kuma:  http://127.0.0.1:${KUMA_PORT:-3001}/"
echo "    Log viewer:   http://127.0.0.1:${DOZZLE_PORT:-5005}/"
fi
echo "======================================================================"
