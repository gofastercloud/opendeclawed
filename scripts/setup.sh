#!/usr/bin/env bash
###############################################################################
# opendeclawed — Setup Script
#
# Interactive or non-interactive setup for the hardened OpenClaw stack.
# Credentials are persisted to .env and openclaw.json IMMEDIATELY as they
# are collected, so a crash never loses what you've already entered.
#
# Usage:
#   Interactive:     ./scripts/setup.sh
#   Non-interactive: ./scripts/setup.sh --non-interactive
#   Quick (quiet):   ./scripts/setup.sh -q
#
# Non-interactive mode reads all values from environment variables or .env file.
# Interactive mode prompts for missing values using secure (silent) input for
# all secrets.
###############################################################################
set -euo pipefail

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
CYAN='\033[0;36m'; BOLD='\033[1m'; DIM='\033[2m'; NC='\033[0m'
OPENCLAW_VERSION="2026.2.14"
info()  { echo -e "${GREEN}[+]${NC} $*"; }
warn()  { echo -e "${YELLOW}[!]${NC} $*"; }
error() { echo -e "${RED}[x]${NC} $*" >&2; exit 1; }
header(){ echo -e "\n${BOLD}${CYAN}── $* ──${NC}"; }
dim()   { echo -e "${DIM}    $*${NC}"; }

# ── Defaults ──────────────────────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_DIR="$(dirname "${SCRIPT_DIR}")"
CONFIG_DIR="${OPENCLAW_CONFIG_DIR:-${HOME}/.openclaw}"
WORKSPACE_DIR="${OPENCLAW_WORKSPACE_DIR:-${CONFIG_DIR}/workspace}"
COMPOSE_FILE="${REPO_DIR}/docker-compose.yml"
ENV_FILE="${REPO_DIR}/.env"
INTERACTIVE=true
SKIP_VALIDATION=false

# Credential vars — populated by prompts or environment
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
VIRUSTOTAL_API_KEY="${VIRUSTOTAL_API_KEY:-}"
CLOUDFLARE_TOKEN="${CLOUDFLARE_TOKEN:-}"
TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN:-}"
INGRESS_MODE="${INGRESS_MODE:-local}"
EGRESS_SUBNET="${EGRESS_SUBNET:-172.28.0.0/24}"
GATEWAY_IP="${GATEWAY_IP:-172.17.0.1}"
TELEMETRY_ENABLED="${TELEMETRY_ENABLED:-false}"
TS_AUTHKEY="${TS_AUTHKEY:-}"
TS_HOSTNAME="${TS_HOSTNAME:-openclaw}"

# ── Parse arguments ───────────────────────────────────────────────────────
for arg in "$@"; do
    case "$arg" in
        --non-interactive|-q) INTERACTIVE=false ;;
        --skip-validation) SKIP_VALIDATION=true ;;
        --help|-h)
            echo "Usage: $0 [--non-interactive | -q] [--help]"
            echo ""
            echo "  --non-interactive, -q  Accept defaults, read config from env vars / .env file"
            echo "  --skip-validation      Accept invalid credential formats (non-interactive only)"
            echo "  --help                 Show this help"
            echo ""
            echo "Environment variables for non-interactive mode:"
            echo "  ANTHROPIC_API_KEY      Anthropic API key (required)"
            echo "  VIRUSTOTAL_API_KEY     VirusTotal API key (recommended)"
            echo "  INGRESS_MODE           local|tunnel|tailscale (default: local)"
            echo "  CLOUDFLARE_TOKEN       Cloudflare tunnel token (if tunnel)"
            echo "  TS_AUTHKEY             Tailscale auth key (if tailscale)"
            echo "  TS_HOSTNAME            Tailscale machine name (default: openclaw)"
            echo "  TELEMETRY_ENABLED      true|false (default: false)"
            echo "  TELEGRAM_BOT_TOKEN     Telegram bot token (optional)"
            exit 0
            ;;
    esac
done

###############################################################################
# ── Helpers ──────────────────────────────────────────────────────────────
###############################################################################

# Write or update a KEY=VALUE pair in .env. Creates .env if it doesn't exist.
# Usage: save_env KEY VALUE
save_env() {
    local key="$1" value="$2"

    # Create .env with header if it doesn't exist yet
    if [ ! -f "${ENV_FILE}" ]; then
        cat > "${ENV_FILE}" << HEADER
# Generated by setup.sh on $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# See .env.example for all available options.
# Permissions: 600 (owner read/write only)
HEADER
        chmod 600 "${ENV_FILE}"
    fi

    # Update existing key or append new one
    if grep -q "^${key}=" "${ENV_FILE}" 2>/dev/null; then
        # Use a temp file to avoid sed -i portability issues
        local tmpfile
        tmpfile=$(mktemp "${ENV_FILE}.XXXXXX")
        chmod 600 "${tmpfile}"
        grep -v "^${key}=" "${ENV_FILE}" > "${tmpfile}"
        printf '%s=%s\n' "${key}" "${value}" >> "${tmpfile}"
        mv "${tmpfile}" "${ENV_FILE}"
    else
        printf '%s=%s\n' "${key}" "${value}" >> "${ENV_FILE}"
    fi
}

# Validate a credential matches its expected format.
# Returns 0 if valid or no pattern defined, 1 if invalid.
# Usage: validate_format VAR_NAME VALUE
validate_format() {
    local var_name="$1" value="$2"
    case "${var_name}" in
        ANTHROPIC_API_KEY)
            if [[ ! "${value}" =~ ^sk-ant- ]]; then
                warn "Doesn't look like an Anthropic API key (expected sk-ant-...)"
                if [ "${INTERACTIVE}" = true ]; then
                    warn "If using an OAuth token, this is fine — press Enter to re-enter or type 'accept' to keep it."
                    read -rp "  > " override
                    [[ "${override}" == "accept" ]] && return 0
                    return 1
                fi
                if [ "${SKIP_VALIDATION}" = true ]; then
                    warn "Accepting in non-interactive mode (--skip-validation)."
                    return 0
                fi
                error "Invalid format in non-interactive mode. Use --skip-validation to override."
                return 1
            fi
            ;;
        VIRUSTOTAL_API_KEY)
            if [[ ! "${value}" =~ ^[a-fA-F0-9]{64}$ ]]; then
                warn "Doesn't look like a VirusTotal key (expected 64-char hex string)"
                if [ "${INTERACTIVE}" = true ]; then
                    read -rp "  Accept anyway? [y/N]: " override
                    [[ "${override}" =~ ^[Yy] ]] && return 0
                    return 1
                fi
                if [ "${SKIP_VALIDATION}" = true ]; then
                    warn "Accepting in non-interactive mode (--skip-validation)."
                    return 0
                fi
                error "Invalid format in non-interactive mode. Use --skip-validation to override."
                return 1
            fi
            ;;
        CLOUDFLARE_TOKEN)
            if [[ ! "${value}" =~ ^eyJ ]]; then
                warn "Doesn't look like a Cloudflare tunnel token (expected eyJ... base64)"
                if [ "${INTERACTIVE}" = true ]; then
                    read -rp "  Accept anyway? [y/N]: " override
                    [[ "${override}" =~ ^[Yy] ]] && return 0
                    return 1
                fi
                if [ "${SKIP_VALIDATION}" = true ]; then
                    warn "Accepting in non-interactive mode (--skip-validation)."
                    return 0
                fi
                error "Invalid format in non-interactive mode. Use --skip-validation to override."
                return 1
            fi
            ;;
        TELEGRAM_BOT_TOKEN)
            if [[ ! "${value}" =~ ^[0-9]+:.+ ]]; then
                warn "Doesn't look like a Telegram bot token (expected 123456789:ABC...)"
                if [ "${INTERACTIVE}" = true ]; then
                    read -rp "  Accept anyway? [y/N]: " override
                    [[ "${override}" =~ ^[Yy] ]] && return 0
                    return 1
                fi
                if [ "${SKIP_VALIDATION}" = true ]; then
                    warn "Accepting in non-interactive mode (--skip-validation)."
                    return 0
                fi
                error "Invalid format in non-interactive mode. Use --skip-validation to override."
                return 1
            fi
            ;;
        TS_AUTHKEY)
            if [[ ! "${value}" =~ ^tskey- ]]; then
                warn "Doesn't look like a Tailscale auth key (expected tskey-auth-... or tskey-client-...)"
                if [ "${INTERACTIVE}" = true ]; then
                    read -rp "  Accept anyway? [y/N]: " override
                    [[ "${override}" =~ ^[Yy] ]] && return 0
                    return 1
                fi
                if [ "${SKIP_VALIDATION}" = true ]; then
                    warn "Accepting in non-interactive mode (--skip-validation)."
                    return 0
                fi
                error "Invalid format in non-interactive mode. Use --skip-validation to override."
                return 1
            fi
            ;;
    esac
    return 0
}

# Prompt for a secret value. Input is NOT echoed to the screen.
# Persists to .env immediately via save_env.
# Usage: ask_secret VAR_NAME "prompt text" [required|optional] [env_key]
# env_key defaults to VAR_NAME if not specified.
ask_secret() {
    local var_name="$1" prompt="$2" required="${3:-optional}" env_key="${4:-$1}"
    local current_val="${!var_name:-}"

    # If already set from env or previous run, keep it
    if [ -n "${current_val}" ]; then
        dim "  ${var_name}: already set (${#current_val} chars)"
        return 0
    fi

    # Non-interactive: skip optional, error on required
    if [ "${INTERACTIVE}" != true ]; then
        if [ "${required}" = "required" ]; then
            error "${var_name} is required but not set. Export it or use interactive mode."
        fi
        return 0
    fi

    echo ""
    if [ "${required}" = "required" ]; then
        echo -e "  ${BOLD}${prompt}${NC} ${RED}(required)${NC}"
    else
        echo -e "  ${prompt} ${DIM}(Enter to skip)${NC}"
    fi

    while true; do
        # -s = silent (no echo), -r = raw (no backslash escape)
        read -rsp "  > " current_val
        echo ""  # newline after silent input

        if [ -z "${current_val}" ]; then
            if [ "${required}" = "required" ]; then
                warn "This credential is required. Please enter a value."
                continue
            else
                dim "Skipped."
                return 0
            fi
        fi

        # Confirm by asking to type again
        read -rsp "  Confirm (paste again): " confirm_val
        echo ""

        if [ "${current_val}" = "${confirm_val}" ]; then
            # Validate format before accepting
            if ! validate_format "${var_name}" "${current_val}"; then
                warn "Re-enter the value."
                current_val=""
                continue
            fi
            # SECURITY: use printf -v instead of eval to prevent shell injection
            printf -v "$var_name" '%s' "$current_val"
            # Persist immediately so a crash doesn't lose it
            save_env "${env_key}" "${current_val}"
            info "Saved + persisted to .env (${#current_val} chars)"
            return 0
        else
            warn "Values don't match. Try again."
        fi
    done
}

# Prompt for a non-secret value (echoed normally).
ask_plain() {
    local var_name="$1" prompt="$2" default="${3:-}"
    local current_val="${!var_name:-${default}}"

    if [ "${INTERACTIVE}" = true ] && [ -z "${current_val}" ]; then
        read -rp "  ${prompt}: " current_val
    fi
    current_val="${current_val:-${default}}"
    printf -v "$var_name" '%s' "$current_val"
}

###############################################################################
header "Step 1/9 — Prerequisites"
###############################################################################

command -v docker >/dev/null 2>&1 || error "Docker not found. Install OrbStack (https://orbstack.dev) or Docker Desktop."
docker compose version >/dev/null 2>&1 || error "Docker Compose V2 not found."

command -v python3 >/dev/null 2>&1 || error "Python 3 not found. Required for config generation."
info "Python: $(python3 --version 2>&1)"

DOCKER_VERSION=$(docker version --format '{{.Server.Version}}' 2>/dev/null || echo "unknown")
info "Docker Engine: ${DOCKER_VERSION}"

if pgrep -q OrbStack 2>/dev/null; then
    info "Runtime: OrbStack"
elif pgrep -q Docker 2>/dev/null || pgrep -q com.docker 2>/dev/null; then
    info "Runtime: Docker Desktop"
else
    info "Runtime: native Docker (or undetected)"
fi

###############################################################################
header "Step 2/9 — Secrets detection (TruffleHog)"
###############################################################################

# Install trufflehog if missing
if command -v trufflehog >/dev/null 2>&1; then
    info "TruffleHog: $(trufflehog --version 2>&1 | head -1)"
else
    info "Installing TruffleHog (secrets scanner)..."
    if command -v brew >/dev/null 2>&1; then
        brew install trufflehog 2>/dev/null || warn "brew install trufflehog failed — install manually"
    else
        warn "TruffleHog not available. Install manually:"
        warn "  macOS:  brew install trufflehog"
        warn "  Linux:  See https://github.com/trufflesecurity/trufflehog#installation"
    fi
    if command -v trufflehog >/dev/null 2>&1; then
        info "TruffleHog installed."
    else
        warn "TruffleHog not available — secrets scanning will be skipped."
        warn "Install later: brew install trufflehog"
    fi
fi

# Install pre-commit if missing
if command -v pre-commit >/dev/null 2>&1; then
    info "pre-commit: $(pre-commit --version 2>&1)"
else
    info "Installing pre-commit (git hook framework)..."
    if command -v brew >/dev/null 2>&1; then
        brew install pre-commit 2>/dev/null || true
    elif command -v uv >/dev/null 2>&1; then
        uv tool install pre-commit 2>/dev/null || true
    elif command -v pipx >/dev/null 2>&1; then
        pipx install pre-commit 2>/dev/null || true
    fi
    if command -v pre-commit >/dev/null 2>&1; then
        info "pre-commit installed."
    else
        warn "pre-commit not available — install later: brew install pre-commit"
    fi
fi

# Install git hooks if this is a git repo
if [ -d "${REPO_DIR}/.git" ]; then
    if command -v pre-commit >/dev/null 2>&1; then
        (cd "${REPO_DIR}" && pre-commit install 2>/dev/null) && info "Pre-commit hooks installed." || true
    else
        dim "pre-commit not found — run 'brew install pre-commit && pre-commit install' to enable git hooks."
    fi
else
    dim "Not a git repo — run 'pre-commit install' after git init."
fi

###############################################################################
header "Step 3/9 — Config directories + .env"
###############################################################################

mkdir -p "${CONFIG_DIR}" "${WORKSPACE_DIR}"
chmod 700 "${CONFIG_DIR}"
chmod 700 "${WORKSPACE_DIR}"
info "Config: ${CONFIG_DIR} (mode 700)"

# Load existing .env if present (re-run scenario)
if [ -f "${ENV_FILE}" ]; then
    set +u
    while IFS='=' read -r key value; do
        # Only export valid variable names, skip comments and blank lines
        if [[ "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
            # Remove surrounding quotes if present
            value="${value%\"}"
            value="${value#\"}"
            value="${value%\'}"
            value="${value#\'}"
            export "${key}=${value}"
        fi
    done < <(grep -v '^\s*#' "${ENV_FILE}" | grep -v '^\s*$')
    set -u
    info "Loaded existing .env (re-run detected)"
fi

# Load existing credentials from openclaw.json (re-run scenario)
OPENCLAW_JSON="${CONFIG_DIR}/openclaw.json"
if [ -f "${OPENCLAW_JSON}" ]; then
    if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
        ANTHROPIC_API_KEY=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    # 2026.x schema: env.ANTHROPIC_API_KEY
    key = cfg.get('env',{}).get('ANTHROPIC_API_KEY','')
    # Legacy fallback: providers.anthropic.apiKey
    if not key:
        key = cfg.get('providers',{}).get('anthropic',{}).get('apiKey','')
    print(key)
except Exception: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
        [ -n "${ANTHROPIC_API_KEY}" ] && info "Loaded Anthropic API key from openclaw.json"
    fi
    if [ -z "${TELEGRAM_BOT_TOKEN:-}" ]; then
        TELEGRAM_BOT_TOKEN=$(python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        cfg = json.load(f)
    # 2026.x: "token"; legacy: "botToken"
    t = cfg.get('channels',{}).get('telegram',{})
    print(t.get('token','') or t.get('botToken',''))
except Exception: pass
" "${OPENCLAW_JSON}" 2>/dev/null) || true
        [ -n "${TELEGRAM_BOT_TOKEN}" ] && info "Loaded Telegram bot token from openclaw.json"
    fi
fi

###############################################################################
header "Step 4/9 — Credentials"
###############################################################################

echo ""
echo -e "${BOLD}  All secrets use secure input — nothing is echoed to screen.${NC}"
echo -e "${DIM}  Credentials are saved to .env IMMEDIATELY — a crash won't lose them.${NC}"
echo -e "${DIM}  See docs/prerequisites.md for how to obtain each key.${NC}"

# ── Required ──
echo ""
echo -e "  ${BOLD}── Required ──${NC}"
dim "Anthropic API key powers all Claude model calls."
dim "Get one at: https://console.anthropic.com → Settings → API Keys"
dim "Or use a Claude Pro/Max OAuth token from the onboarding wizard."
ask_secret ANTHROPIC_API_KEY "Anthropic API key (sk-ant-...)" required ANTHROPIC_API_KEY

# ── Recommended ──
echo ""
echo -e "  ${BOLD}── Recommended ──${NC}"
dim "VirusTotal API key enables skill scanning before install."
dim "Free: https://www.virustotal.com → avatar → API key"
ask_secret VIRUSTOTAL_API_KEY "VirusTotal API key" optional VIRUSTOTAL_API_KEY

# ── Ingress ──
echo ""
echo -e "  ${BOLD}── Ingress mode ──${NC}"
if [ "${INTERACTIVE}" = true ] && [ -z "${CLOUDFLARE_TOKEN}" ]; then
    echo ""
    echo "  How will you access OpenClaw?"
    echo "    1) local     — 127.0.0.1 only (default, most secure)"
    echo "    2) tunnel    — Cloudflare Tunnel (zero exposed ports, internet-accessible)"
    echo "    3) tailscale — Tailscale mesh VPN (WireGuard, ACL-controlled)"
    echo ""
    read -rp "  Choose [1]: " ingress_choice
    case "${ingress_choice}" in
        2|tunnel)
            INGRESS_MODE="tunnel"
            dim "Create a tunnel at: https://one.dash.cloudflare.com → Tunnels"
            dim "See docs/setup-guide.md for Cloudflare Access + GitHub OAuth setup."
            ask_secret CLOUDFLARE_TOKEN "Cloudflare Tunnel token (eyJ...)" required CLOUDFLARE_TOKEN
            ;;
        3|tailscale)
            INGRESS_MODE="tailscale"
            dim "Generate an auth key at: https://login.tailscale.com/admin/settings/keys"
            dim "Use a reusable key for unattended restarts. See docs/setup-guide.md."
            ask_secret TS_AUTHKEY "Tailscale auth key (tskey-auth-...)" required TS_AUTHKEY
            echo ""
            read -rp "  Tailscale hostname [openclaw]: " ts_host
            TS_HOSTNAME="${ts_host:-openclaw}"
            save_env TS_HOSTNAME "${TS_HOSTNAME}"
            info "Tailscale hostname: ${TS_HOSTNAME}"
            ;;
        *)
            INGRESS_MODE="local"
            info "Ingress: local-only (127.0.0.1:18789)"
            ;;
    esac
else
    if [ -n "${CLOUDFLARE_TOKEN}" ]; then INGRESS_MODE="tunnel"; fi
    if [ -n "${TS_AUTHKEY}" ]; then INGRESS_MODE="tailscale"; fi
    info "Ingress: ${INGRESS_MODE} (from environment)"
fi

# ── Messaging (optional) ──
echo ""
echo -e "  ${BOLD}── Messaging channels (optional) ──${NC}"
dim "Configure at least one to interact with OpenClaw remotely."

# Telegram
if [ "${INTERACTIVE}" = true ] && [ -z "${TELEGRAM_BOT_TOKEN}" ]; then
    echo ""
    read -rp "  Set up Telegram bot? [y/N]: " setup_telegram
    if [[ "${setup_telegram}" =~ ^[Yy] ]]; then
        dim "Create a bot: message @BotFather on Telegram → /newbot"
        dim "Then /setjoingroups → Disable, /setprivacy → Enable"
        ask_secret TELEGRAM_BOT_TOKEN "Telegram bot token (123456789:ABC...)" optional TELEGRAM_BOT_TOKEN
    fi
fi

# ── Telemetry (opt-in) ──
if [ "${INTERACTIVE}" = true ] && [ "${TELEMETRY_ENABLED}" != "true" ]; then
    echo ""
    echo -e "  ${BOLD}── Telemetry (opt-in) ──${NC}"
    dim "OpenClaw can send anonymous usage telemetry to help the project."
    dim "No credentials, prompts, or PII are ever transmitted."
    read -rp "  Enable native telemetry? [y/N]: " enable_telem
    if [[ "${enable_telem}" =~ ^[Yy] ]]; then
        TELEMETRY_ENABLED="true"
    else
        TELEMETRY_ENABLED="false"
    fi
    save_env TELEMETRY_ENABLED "${TELEMETRY_ENABLED}"
fi

info "All credentials collected + persisted."

###############################################################################
header "Step 5/9 — Gateway token"
###############################################################################

if [ -f "${CONFIG_DIR}/.gateway-token" ]; then
    OPENCLAW_GATEWAY_TOKEN="$(cat "${CONFIG_DIR}/.gateway-token")"
    info "Using existing gateway token."
elif [ -n "${OPENCLAW_GATEWAY_TOKEN:-}" ]; then
    echo -n "${OPENCLAW_GATEWAY_TOKEN}" > "${CONFIG_DIR}/.gateway-token"
    chmod 600 "${CONFIG_DIR}/.gateway-token"
    info "Saved gateway token from environment."
else
    OPENCLAW_GATEWAY_TOKEN="$(openssl rand -hex 32)"
    echo -n "${OPENCLAW_GATEWAY_TOKEN}" > "${CONFIG_DIR}/.gateway-token"
    chmod 600 "${CONFIG_DIR}/.gateway-token"
    info "Generated new gateway token (64 hex chars)."
fi
save_env OPENCLAW_GATEWAY_TOKEN "${OPENCLAW_GATEWAY_TOKEN}"

# ── Generate LiteLLM master key (internal-only, random per install) ──
if [ -n "${LITELLM_MASTER_KEY:-}" ] && [ "${LITELLM_MASTER_KEY}" != "sk-opendeclawed-internal" ]; then
    info "Using existing LiteLLM master key."
else
    LITELLM_MASTER_KEY="sk-litellm-$(openssl rand -hex 16)"
    info "Generated random LiteLLM master key."
fi
save_env LITELLM_MASTER_KEY "${LITELLM_MASTER_KEY}"

# Also persist non-secret config to .env
save_env OPENCLAW_CONFIG_DIR "${CONFIG_DIR}"
save_env OPENCLAW_WORKSPACE_DIR "${WORKSPACE_DIR}"
save_env INTERNAL_SUBNET "${INTERNAL_SUBNET:-172.27.0.0/24}"
save_env EGRESS_SUBNET "${EGRESS_SUBNET:-172.28.0.0/24}"
save_env GATEWAY_IP "${GATEWAY_IP:-172.17.0.1}"
save_env INGRESS_MODE "${INGRESS_MODE}"
# Write empty defaults for optional profile vars so Docker Compose
# doesn't emit "variable is not set" warnings for unused profiles.
[ -z "${CLOUDFLARE_TOKEN}" ]    && save_env CLOUDFLARE_TOKEN ""
[ -z "${TS_AUTHKEY}" ]          && save_env TS_AUTHKEY ""
[ -z "${TS_HOSTNAME}" ]         && save_env TS_HOSTNAME "openclaw"

###############################################################################
header "Step 6/9 — Write openclaw.json"
###############################################################################

OPENCLAW_JSON="${CONFIG_DIR}/openclaw.json"

if [ -f "${OPENCLAW_JSON}" ]; then
    info "Backing up existing config: ${OPENCLAW_JSON} -> ${OPENCLAW_JSON}.bak"
    cp "${OPENCLAW_JSON}" "${OPENCLAW_JSON}.bak"
    rm -f "${OPENCLAW_JSON}"
fi

# SECURITY: Pass all secrets via environment variables to Python, NOT via
# shell interpolation into code. Shell interpolation breaks on quotes,
# backslashes, and $ chars in API keys, and is an injection vector.
TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN}" \
INGRESS_MODE="${INGRESS_MODE}" \
LITELLM_PORT="${LITELLM_PORT:-4000}" \
LITELLM_MASTER_KEY="${LITELLM_MASTER_KEY}" \
OPENCLAW_JSON_PATH="${OPENCLAW_JSON}" \
OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN}" \
TS_HOSTNAME="${TS_HOSTNAME:-openclaw}" \
OPENCLAW_VERSION="${OPENCLAW_VERSION}" \
python3 << 'PYEOF'
import json, os, secrets
from datetime import datetime, timezone

litellm_port = os.environ.get("LITELLM_PORT", "4000")
litellm_key  = os.environ.get("LITELLM_MASTER_KEY", "sk-opendeclawed-internal")
ingress_mode = os.environ.get("INGRESS_MODE", "local")
gateway_token = os.environ.get("OPENCLAW_GATEWAY_TOKEN", secrets.token_hex(24))
ts_hostname  = os.environ.get("TS_HOSTNAME", "openclaw")
oc_version   = os.environ.get("OPENCLAW_VERSION", "2026.2.14")

now = datetime.now(timezone.utc).isoformat()

config = {
    "meta": {
        "lastTouchedVersion": oc_version,
        "lastTouchedAt": now
    },
    "wizard": {
        "lastRunAt": now,
        "lastRunVersion": oc_version,
        "lastRunCommand": "onboard",
        "lastRunMode": "local"
    },
    "env": {},
    "models": {
        "mode": "merge",
        "providers": {
            "litellm": {
                "baseUrl": f"http://litellm:{litellm_port}/v1",
                "apiKey": litellm_key,
                "api": "openai-responses",
                "models": [
                    {
                        "id": "litellm/claude",
                        "name": "Claude Sonnet (via LiteLLM)",
                        "reasoning": True,
                        "input": ["text"],
                        "contextWindow": 200000,
                        "maxTokens": 8192
                    },
                    {
                        "id": "litellm/haiku",
                        "name": "Claude Haiku (via LiteLLM)",
                        "reasoning": False,
                        "input": ["text"],
                        "contextWindow": 200000,
                        "maxTokens": 8192
                    },
                    {
                        "id": "litellm/local-chat",
                        "name": "Local Chat (via LiteLLM)",
                        "reasoning": False,
                        "input": ["text"],
                        "cost": {"input": 0, "output": 0, "cacheRead": 0, "cacheWrite": 0},
                        "contextWindow": 32768,
                        "maxTokens": 2048
                    },
                    {
                        "id": "litellm/local-embed",
                        "name": "Local Embed (Nomic v1.5 via LiteLLM)",
                        "reasoning": False,
                        "input": ["text"],
                        "cost": {"input": 0, "output": 0, "cacheRead": 0, "cacheWrite": 0},
                        "contextWindow": 8192,
                        "maxTokens": 512
                    }
                ]
            }
        }
    },
    "agents": {
        "defaults": {
            "model": {
                "primary": "litellm/claude",
                "fallbacks": [
                    "litellm/haiku"
                ]
            },
            "models": {
                "litellm/claude": {"alias": "Sonnet"},
                "litellm/haiku":  {"alias": "Haiku"}
            },
            "workspace": "/home/node/.openclaw/workspace",
            "heartbeat": {
                "every": "60m",
                "model": "litellm/haiku",
                "target": "last",
                "includeReasoning": False,
                "ackMaxChars": 300
            },
            "sandbox": {
                "mode": "non-main",
                "scope": "agent"
            }
        }
    },
    "commands": {
        "native": "auto",
        "nativeSkills": "auto"
    },
    "gateway": {
        "port": 18789,
        "mode": "local",
        "bind": "lan",
        "controlUi": {
            "enabled": True,
            "allowInsecureAuth": ingress_mode == "local"
        },
        "auth": {
            "mode": "token",
            "token": gateway_token
        },
        "trustedProxies": ["172.28.0.0/24", "172.17.0.0/24", "192.168.65.0/24"],
        "tailscale": {
            "mode": "serve" if ingress_mode == "tailscale" else "off",
            "resetOnExit": False
        }
    }
}

# Inject channel configs with secure defaults
telegram_token = os.environ.get("TELEGRAM_BOT_TOKEN", "")

if telegram_token:
    config["channels"] = {}
    config["plugins"] = {"entries": {}}

    config["channels"]["telegram"] = {
        "enabled": True,
        "dmPolicy": "pairing",
        "botToken": telegram_token,
        "groupPolicy": "allowlist",
        "streamMode": "partial"
    }
    config["plugins"]["entries"]["telegram"] = {"enabled": True}

# Remove empty env/plugins if nothing was set
if not config["env"]:
    del config["env"]
if "plugins" in config and not config["plugins"].get("entries"):
    del config["plugins"]

out_path = os.environ.get("OPENCLAW_JSON_PATH",
                          os.path.expanduser("~/.openclaw/openclaw.json"))
with open(out_path, "w") as f:
    json.dump(config, f, indent=2)
PYEOF

chmod 600 "${OPENCLAW_JSON}"
info "Written: ${OPENCLAW_JSON} (mode 600)"

###############################################################################
header "Step 7/9 — Verify .env"
###############################################################################

# .env has been built incrementally by save_env calls above.
# Just verify it exists and has correct permissions.
if [ -f "${ENV_FILE}" ]; then
    chmod 600 "${ENV_FILE}"
    local_keys=$(grep -c '=' "${ENV_FILE}" 2>/dev/null || echo 0)
    info ".env: ${local_keys} keys, mode 600"
else
    warn ".env missing — this shouldn't happen. Re-run setup."
fi

# ── Check for OpenClaw image ──
OPENCLAW_IMAGE="${OPENCLAW_IMAGE:-openclaw:local}"
if ! docker image inspect "${OPENCLAW_IMAGE}" >/dev/null 2>&1; then
    warn "OpenClaw image '${OPENCLAW_IMAGE}' not found locally."
    echo ""
    echo "  You need to build or pull the OpenClaw image before starting."
    echo ""
    echo "  Option A — Build from source (recommended, most secure):"
    echo "    git clone https://github.com/openclaw/openclaw /tmp/openclaw-src"
    echo "    docker build -t openclaw:local -f /tmp/openclaw-src/Dockerfile /tmp/openclaw-src"
    echo ""
    echo "  Option B — Pull pre-built from Docker Hub:"
    echo "    docker pull alpine/openclaw"
    echo "    # Then set OPENCLAW_IMAGE=alpine/openclaw in .env"
    echo ""
    if [ "${INTERACTIVE}" = true ]; then
        read -rp "  Try pulling alpine/openclaw now? [y/N]: " pull_choice
        if [[ "${pull_choice}" =~ ^[Yy] ]]; then
            info "Pulling alpine/openclaw..."
            docker pull alpine/openclaw || error "Pull failed. Build from source instead."
            OPENCLAW_IMAGE="alpine/openclaw"
            save_env OPENCLAW_IMAGE "${OPENCLAW_IMAGE}"
            info "Using image: ${OPENCLAW_IMAGE}"
        else
            warn "Skipping — set OPENCLAW_IMAGE in .env and re-run, or build locally first."
        fi
    else
        # Non-interactive: auto-pull if image not available
        info "Pulling alpine/openclaw (non-interactive)..."
        if docker pull alpine/openclaw 2>/dev/null; then
            OPENCLAW_IMAGE="alpine/openclaw"
            save_env OPENCLAW_IMAGE "${OPENCLAW_IMAGE}"
            info "Using image: ${OPENCLAW_IMAGE}"
        else
            warn "Pull failed — set OPENCLAW_IMAGE in .env and re-run, or build locally first."
        fi
    fi
fi

###############################################################################
header "Step 8/9 — Start stack"
###############################################################################

# Onboarding — config is pre-populated, wizard should not be needed.
# Offer to run it anyway in interactive mode (default: skip).
if [ "${INTERACTIVE}" = true ]; then
    echo ""
    dim "Config is fully pre-populated. The onboarding wizard is not required."
    read -rp "  Run OpenClaw onboarding wizard anyway? [y/N]: " run_onboard
    if [[ "${run_onboard}" =~ ^[Yy] ]]; then
        info "Starting onboarding wizard..."
        # CLI entrypoint is "node dist/index.js", so just pass the subcommand.
        docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" --profile cli \
            run --rm openclaw-cli onboard --no-install-daemon \
            || warn "Onboarding exited. Re-run: docker compose --profile cli run --rm openclaw-cli onboard"
        # Clean up containers from onboarding attempt before starting the full stack.
        # Without this, stale port/network allocations cause "Address already in use".
        docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" down --remove-orphans 2>/dev/null || true
    fi
fi

# Build profile flags
PROFILES=()

# LLM backend: Ollama on host via LiteLLM proxy

# ── Generate litellm_config.yaml (LLM router config) ──────────────────
# LiteLLM sits between OpenClaw and the actual LLM backends. All local
# model traffic goes through litellm:4000. To swap backends later, just
# edit this YAML — no openclaw.json changes needed.
LITELLM_CONFIG="${REPO_DIR}/litellm_config.yaml"
LITELLM_PORT="${LITELLM_PORT:-4000}"

write_litellm=true
if [ -f "${LITELLM_CONFIG}" ]; then
    if [ "${INTERACTIVE}" != true ]; then
        warn "Backing up existing litellm_config.yaml to litellm_config.yaml.bak"
        cp "${LITELLM_CONFIG}" "${LITELLM_CONFIG}.bak"
    else
        warn "litellm_config.yaml already exists."
        read -rp "  Overwrite? (existing backed up to .bak) [y/N]: " overwrite_litellm
        if [[ ! "${overwrite_litellm}" =~ ^[Yy] ]]; then
            info "Keeping existing litellm_config.yaml"
            write_litellm=false
        else
            cp "${LITELLM_CONFIG}" "${LITELLM_CONFIG}.bak"
            info "Backed up to litellm_config.yaml.bak"
        fi
    fi
fi

if [ "${write_litellm}" = true ]; then
cat > "${LITELLM_CONFIG}" << 'LITELLMEOF'
# LiteLLM Proxy configuration — generated by setup.sh
# Edit this file to add/change LLM backends without modifying openclaw.json.
#
# Anthropic models: ANTHROPIC_API_KEY is read from env (docker-compose.yml).
# Local models: route to Ollama running on the host (localhost:11434).
# To use MLX, vLLM, or another backend, change the api_base URLs below.
# Restart after editing: docker compose restart litellm
#
# Docs: https://docs.litellm.ai/docs/proxy/configs

model_list:
  # ── Anthropic models (API key from env) ──
  - model_name: claude
    litellm_params:
      model: anthropic/claude-sonnet-4-5-20250929
      drop_params: true
  - model_name: haiku
    litellm_params:
      model: anthropic/claude-haiku-4-5-20251001
      drop_params: true

  # ── Chat / completion model (Ollama on host) ──
  - model_name: local-chat
    litellm_params:
      model: openai/qwen3:8b
      api_base: "http://host.docker.internal:11434/v1"
      api_key: "not-needed"

  # ── Embedding model (Ollama on host) ──
  - model_name: local-embed
    litellm_params:
      model: openai/nomic-embed-text
      api_base: "http://host.docker.internal:11434/v1"
      api_key: "not-needed"

# master_key is set via LITELLM_MASTER_KEY env var (docker-compose.yml).
# ANTHROPIC_API_KEY is set via env var (docker-compose.yml).
# Do NOT set keys in general_settings — LiteLLM doesn't expand ${} in YAML.
LITELLMEOF
info "Written: ${LITELLM_CONFIG}"
fi
save_env LITELLM_PORT "${LITELLM_PORT}"

# ── Blocky DNS config ──
# Blocky config is bind-mounted from ./examples/blocky-config.yml in docker-compose.yml.
# No volume population needed.
info "Blocky config: bind-mount from examples/blocky-config.yml (ready)"

case "${INGRESS_MODE}" in
    tunnel)    PROFILES+=(--profile tunnel) ;;
    tailscale) PROFILES+=(--profile tailscale) ;;
esac

# Monitoring (Watchtower + Dozzle + socket-proxy) is always enabled — no profile gate.
info "Monitoring enabled (Watchtower + Dozzle) — always on"

info "Starting stack..."
docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" "${PROFILES[@]}" up -d

###############################################################################
header "Step 9/9 — Validate"
###############################################################################

sleep 3

docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" ps --format '{{.Name}}\t{{.Status}}' 2>/dev/null \
    | while IFS=$'\t' read -r name status; do
        info "  ${name}: ${status}"
    done

# Firewall check
GATEWAY_ID=$(docker ps -q -f name=opendeclawed-gateway 2>/dev/null || true)
if [ -n "${GATEWAY_ID}" ]; then
    FIREWALL_OK=true
    for TEST_IP in 192.168.1.1 10.0.0.1 172.16.0.1; do
        if docker exec "${GATEWAY_ID}" curl -sf --connect-timeout 2 "http://${TEST_IP}/" 2>/dev/null; then
            warn "FIREWALL CHECK FAILED — containers can reach ${TEST_IP}!"
            FIREWALL_OK=false
            break
        fi
    done
    if [ "${FIREWALL_OK}" = true ]; then
        info "FIREWALL CHECK PASSED — private networks unreachable from containers"
    fi
fi

# ── Auto-pair CLI device ─────────────────────────────────────────────
# The CLI generates a keypair on first connection and sends a pairing
# request to the gateway. Without approval, CLI commands fail with
# "pairing required". We automate this so the CLI works immediately.
#
# Flow:
#   1. Run CLI briefly — it connects to gateway, gets rejected, but the
#      pairing request lands in ~/.openclaw/devices/pending.json
#   2. Read the pending request from the bind-mounted host filesystem
#   3. Approve it by writing to paired.json (gateway reads on next connect)
OPENCLAW_IMAGE="${OPENCLAW_IMAGE:-openclaw:local}"
if docker image inspect "${OPENCLAW_IMAGE}" >/dev/null 2>&1; then
    info "Auto-pairing CLI device..."
    mkdir -p "${CONFIG_DIR}/devices"

    # Wait for gateway to be healthy (healthcheck: curl /health)
    printf "  Waiting for gateway health"
    CLI_AUTOPAIR_SKIP=""
    for ((i=1; i<=30; i++)); do
        if docker exec opendeclawed-gateway curl -sf http://127.0.0.1:${GATEWAY_PORT:-18789}/health >/dev/null 2>&1; then
            echo " ready."
            break
        fi
        printf "."
        sleep 2
        if [ "$i" = "30" ]; then
            echo ""
            warn "Gateway not healthy after 60s — skipping CLI auto-pair."
            CLI_AUTOPAIR_SKIP=true
        fi
    done

    if [ "${CLI_AUTOPAIR_SKIP:-}" != "true" ]; then
        # Run CLI briefly — the connection attempt creates the pairing request.
        # The command will fail (pairing required), but that's expected.
        docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" \
            --profile cli run --rm -T openclaw-cli nodes status >/dev/null 2>&1 &
        CLI_PAIR_PID=$!

        # Wait for pending request to appear (up to 15s)
        PENDING_FILE="${CONFIG_DIR}/devices/pending.json"
        PAIRED_FILE="${CONFIG_DIR}/devices/paired.json"

        for ((i=1; i<=15; i++)); do
            if [ -f "${PENDING_FILE}" ] && \
               python3 -c "
import json, sys
try:
    with open(sys.argv[1]) as f:
        d = json.load(f)
    # pending.json is {deviceId: {device...}} — check for non-empty dict entries
    sys.exit(0 if isinstance(d, dict) and any(isinstance(v, dict) and v for v in d.values()) else 1)
except:
    sys.exit(1)
" "${PENDING_FILE}" 2>/dev/null; then
                break
            fi
            sleep 1
        done

        # Clean up the CLI process
        kill "${CLI_PAIR_PID}" 2>/dev/null || true
        wait "${CLI_PAIR_PID}" 2>/dev/null || true

        # Approve pending CLI devices from the host filesystem
        PENDING_FILE="${PENDING_FILE}" \
        PAIRED_FILE="${PAIRED_FILE}" \
        python3 << 'PYEOF'
import json, os, secrets, time

pending_path = os.environ["PENDING_FILE"]
paired_path  = os.environ["PAIRED_FILE"]

# Read pending requests
try:
    with open(pending_path) as f:
        pending = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    pending = {}

if not pending or not any(isinstance(v, dict) and v for v in pending.values()):
    print("  No pending CLI devices — skipping.")
    exit(0)

# Read existing paired devices
try:
    with open(paired_path) as f:
        paired = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    paired = {}

now_ms = int(time.time() * 1000)
approved = 0

for device_id, device in list(pending.items()):
    if not isinstance(device, dict):
        continue
    # Add required fields for operator-level access
    device.setdefault("token", secrets.token_hex(32))
    device.setdefault("role", "operator")
    device.setdefault("roles", ["operator"])
    device.setdefault("scopes", [
        "operator.admin",
        "operator.approvals",
        "operator.pairing"
    ])
    device.setdefault("name", "gateway-cli")
    device.setdefault("pairedAt", now_ms)
    device["lastSeenAt"] = now_ms
    paired[device_id] = device
    approved += 1

if approved > 0:
    with open(paired_path, "w") as f:
        json.dump(paired, f, indent=2)
    try:
        os.chmod(paired_path, 0o600)
    except OSError:
        pass
    # Clear pending
    with open(pending_path, "w") as f:
        json.dump({}, f)
    print(f"  Auto-approved {approved} CLI device(s).")
else:
    print("  No CLI devices found in pending requests.")
PYEOF
    fi
else
    dim "OpenClaw image not found — skipping CLI auto-pair."
fi

# Secrets scan — verify nothing leaked into tracked files
if command -v trufflehog >/dev/null 2>&1; then
    info "Running TruffleHog secrets scan on working tree..."
    if trufflehog filesystem "${REPO_DIR}" \
        --exclude-paths="${REPO_DIR}/.trufflehog-config.yaml" \
        --no-update --fail 2>/dev/null; then
        info "SECRETS SCAN PASSED — no credentials detected in repo files"
    else
        warn "SECRETS SCAN FLAGGED ISSUES — review: ./scripts/scan-secrets.sh"
    fi
else
    dim "TruffleHog not installed — skipping secrets scan."
fi

# ── Detect ingress IPs ───────────────────────────────────────────────
# Wait for mesh/tunnel containers to establish connections, then
# extract assigned IPs for the access URL summary.

detect_ingress_ip() {
    local mode="${1}"
    local max_wait=30
    local elapsed=0

    case "${mode}" in
        tailscale)
            printf "  Waiting for Tailscale to connect"
            while [ "${elapsed}" -lt "${max_wait}" ]; do
                TS_IP=$(docker exec opendeclawed-tailscale tailscale ip -4 2>/dev/null) && break
                printf "."
                sleep 2
                elapsed=$((elapsed + 2))
            done
            echo ""
            if [ -n "${TS_IP:-}" ]; then
                TS_FQDN=$(docker exec opendeclawed-tailscale tailscale status --json 2>/dev/null \
                    | python3 -c "import sys,json; print(json.load(sys.stdin)['Self']['DNSName'].rstrip('.'))" 2>/dev/null) || true
                info "Tailscale IP: ${TS_IP}"
                [ -n "${TS_FQDN:-}" ] && info "Tailscale FQDN: ${TS_FQDN}"
            else
                warn "Tailscale not connected yet. Check: docker logs opendeclawed-tailscale"
            fi
            ;;
    esac
}

# Run detection for active ingress mode
case "${INGRESS_MODE}" in
    tailscale) detect_ingress_ip "${INGRESS_MODE}" ;;
esac

###############################################################################
# ── Summary ──
###############################################################################

echo ""
echo "======================================================================"
echo -e "  ${BOLD}${GREEN}Setup complete.${NC}"
echo "======================================================================"
echo ""
echo "  Credentials stored:"
echo "    Anthropic API key:  .env (used by LiteLLM container only)"
[ -n "${VIRUSTOTAL_API_KEY}" ] && \
echo "    VirusTotal API key: .env"
[ -n "${CLOUDFLARE_TOKEN}" ] && \
echo "    Cloudflare token:   .env"
[ -n "${TS_AUTHKEY}" ] && \
echo "    Tailscale auth key: .env"
[ -n "${TELEGRAM_BOT_TOKEN}" ] && \
echo "    Telegram bot token: ~/.openclaw/openclaw.json + .env"
echo "    Gateway token:      ~/.openclaw/.gateway-token + .env"
echo ""
echo "  File permissions:"
echo "    ~/.openclaw/            → 700 (owner only)"
echo "    ~/.openclaw/openclaw.json → 600"
echo "    .env                    → 600"
echo "    ~/.openclaw/.gateway-token → 600"
echo ""
echo "  Ingress: ${INGRESS_MODE}"
echo ""
case "${INGRESS_MODE}" in
    local)
        echo "  Access URLs:"
        echo "    Gateway:      http://localhost:${GATEWAY_PORT:-18789}/?token=${OPENCLAW_GATEWAY_TOKEN}"
        echo "    Dozzle Logs:  http://127.0.0.1:${DOZZLE_PORT:-5005}/"
        ;;
    tunnel)
        TUNNEL_HOST="${CLOUDFLARE_TUNNEL_ROUTE:-openclaw.example.com}"
        echo "  Access URLs:"
        echo "    Gateway:      https://${TUNNEL_HOST}/?token=${OPENCLAW_GATEWAY_TOKEN}"
        echo "    Dozzle Logs:  http://127.0.0.1:${DOZZLE_PORT:-5005}/"
        ;;
    tailscale)
        BASE="${TS_FQDN:-${TS_HOSTNAME:-openclaw}.<your-tailnet>.ts.net}"
        echo "  Access URLs:"
        echo "    Gateway:      https://${BASE}/?token=${OPENCLAW_GATEWAY_TOKEN}"
        [ -n "${TS_IP:-}" ] && echo "    Tailscale IP: ${TS_IP}"
        echo "    Dozzle Logs:  http://127.0.0.1:${DOZZLE_PORT:-5005}/"
        ;;
esac
echo "  Telemetry: ${TELEMETRY_ENABLED}"
echo ""
echo "  Commands:"
echo "    Logs:    docker compose logs -f"
echo "    Stop:    docker compose down"
echo "    Doctor:  docker compose run --rm --profile cli openclaw-cli doctor"
echo "    Health:  curl http://127.0.0.1:${GATEWAY_PORT:-18789}/health"
echo "    Secrets: ./scripts/scan-secrets.sh        (scan working tree)"
echo "             ./scripts/scan-secrets.sh --full  (scan git history)"
[ -n "${VIRUSTOTAL_API_KEY}" ] && \
echo "    Install: \"install skill <name>\" via Telegram (safe-install skill)"
echo ""
echo "  Monitoring:"
echo "    Dozzle Logs:  http://127.0.0.1:${DOZZLE_PORT:-5005}/"
echo "======================================================================"
